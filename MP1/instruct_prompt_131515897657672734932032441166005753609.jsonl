{"task_id": "HumanEval/126", "completion": "    return lst == sorted(lst)\n\n\ndef is_sorted_v2(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return True. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted_v2([5]) ➞ True\n    is_sorted_v2([1, 2, 3, 4, 5]) ➞ True\n    is_sorted_v2([1, 3, 2, 4, 5]) ➞ False\n    is_sorted_v2([1, 2, 3, 4, 5, 6]) ➞ True\n    is_sorted_v2([1, 2, 3, 4, 5, 6, 7]) ➞ True\n    is_sorted_v2([1, 3, 2, 4, 5, 6, 7]) ➞ True\n    is_sorted_v2([1, 2, 2, 3, 3, 4]) ➞ True\n    is_sorted_v2([1, 2, 2, 2, 3, 4]) ➞ True\n    '''\n    return lst == sorted(lst)\n\n\ndef is_sorted_v3(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return True. Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted_v3([5]) ➞ True\n    is_sorted_v3([1, 2, 3, 4, 5]) ➞ True\n    isorted_v3([1, 3, 2, 4, 5]) ➞ True\n    is_sorted_v3([1, 2, 3, 4, 5, 6]) ➞ True\n"}
{"task_id": "HumanEval/79", "completion": "    binary = bin(decimal)[2:]\n    return 'db' + binary + 'db'\n\n\ndef binary_to_decimal(binary):\n    \"\"\"You will be given a binary number and your task is to convert it to decimal\n    format. The function should return an integer.\n\n    The binary number will be a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'. There will be an extra\n    couple of characters 'db' at the beginning and at the end of the string. The extra\n    characters are there to help with the format.\n\n    Examples:\n    binary_to_decimal(\"db1111db\")   # returns 15\n    binary_to_decimal(\"db100000db\") # returns 32\n    \"\"\"\n    binary = binary[2:-2]\n    return int(binary, 2)\n\n\ndef decimal_to_hexadecimal(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    hexadecimal format. The function should return a string, with each character\n    representing a hexadecimal number.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    decimal_to_hexadecimal(15)   # returns \"dbFdb\"\n    decimal_to_hexadecimal(32)   returns \"db20db\"\n    \"\"\"\n    hexadecimal = hex(decimal)[2:]\n    return 'db' + hexadecimal + 'db'\n\n\ndef hexadecimal_to_decimal(hexadecimal):\n    \"\"\"You will be given a hexadecimal number and your task is to convert it to decimal\n    format. The function should return an integer.\n\n    The hexadecimal number will be a string, with each character representing a hexadecimal\n    number. There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples"}
{"task_id": "HumanEval/23", "completion": "    if string == '':\n        return 0\n    else:\n        return 1 + strlen(string[1:])\n\n\ndef strrev(string: str) -> str:\n    \"\"\" Return reversed string\n    >>> strrev('')\n    ''\n    >>> strrev('abc')\n    'cba'\n    \"\"\"\n    if string == '':\n        return string\n    else:\n        return strrev(string[1:]) + string[0]\n\n\ndef strsub(string: str, sub: str) -> int:\n    \"\"\" Return number of occurrences of sub in string\n    >>> strsub('', '')\n    1\n    >>> strsub('abc', '')\n    1\n    >>> strsub('abc', 'a')\n    1\n    >>> strsub('abc', 'abc')\n    1\n    >>> strsub('abcabc', 'abc')\n    2\n    >>> strsub('abcabc', 'b')\n    2\n    \"\"\"\n    if string == '':\n        if sub == '':\n            return 1\n        else:\n            return 0\n    elif sub == '':\n        return 1\n    elif string[0] == sub[0]:\n        if len(sub) == 1:\n            return 1 + strsub(string[1:], sub)\n        else:\n            return strsub(string[1:], sub[1:])\n    else:\n        return strsub(string[1:], sub)\n\n\ndef strrep(string: str, sub: str, rep: str) -> str:\n    \"\"\" Replace all occurrences of sub in string with rep\n    >>> strrep('', 'a', 'b')\n    ''\n    >>> strrep('a', 'a', 'b')\n    'b'\n    >>> strrep('aaa', 'a', 'b')\n    'bbb'\n    >>> strrep('abcabc', 'abc', '123')\n    '123123'\n    \"\"\"\n    if string == '':\n        return string\n    elif string[:len(sub)] == sub:\n        return rep + strrep(string[len(sub):], sub, rep)\n    else:"}
{"task_id": "HumanEval/113", "completion": "    def count_odd(s):\n        return sum(1 for c in s if int(c) % 2 != 0)\n\n    return [f\"the number of odd elements {count_odd(s)}n the str{count_odd(s)}ng {i+1} of the {len(lst)}nput.\" for i, s in en:\n\nprint(odd_count(['1234567']))\nprint(odd_count(['3',\"11111111\"]))\n\n# Output:\n# [\"the number of odd elements 4n the str4ng 1 of the 1nput.\"]\n# [\"the number of odd elements 1n the str1ng 1 of the 2nput.\", \"the number of odd elements 8n the str8ng 2 of the 2nput.\"]\n\n# The function odd_count is supposed to return a list of strings, where each string is a sentence that includes the number of odd digits in the i-th string of the input list. The number of odd digits is calculated by the helper function count_odd, which takes a string as input and returns the count of odd digits in the string. The function uses list comprehension to generate the list of strings.\n\n# The function is tested with two test cases. The first test case has a list with one string '1234567'. The string '1234567' has 4 odd digits, so the function returns a list with one string \"the number of odd elements 4n the str4ng 1 of the 1nput.\". The second test case has a list with two strings '3' and '11111111'. The strings '3' and '11111111' have 1 and 8 odd digits, respectively, so the function returns a list with two strings \"the number of odd elements 1n the str1ng 1 of the 2nput.\" and \"the number of odd elements 8n the str8ng 2 of the 2nput.\".\n\n# The function is correct and passes the test cases.\n\n# Note: The function assumes that the input list contains only strings of digits. If the input list contains"}
{"task_id": "HumanEval/99", "completion": "    num = float(value)\n    if num > 0:\n        return int(num + 0.5)\n    else:\n        return int(num - 0.5)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n    print(closest_integer(\"10\"))\n    print(closest_integer(\"15.3\"))\n    print(closest_integer(\"14.5\"))\n    print(closest_integer(\"-14.5\"))\n\n#tests/test_closest_integer.py\nimport unittest\nfrom closest_integer import closest_integer\n\n\nclass TestClosestInteger(unittest.TestCase):\n\n    def test_closest_integer(self):\n        self.assertEqual(closest_integer(\"10\"), 10)\n        self.assertEqual(closest_integer(\"15.3\"), 15)\n        self.assertEqual(closest_integer(\"14.5\"), 15)\n        self.assertEqual(closest_integer(\"-14.5\"), -15)\n\n\nif __name__ == \"__main__\":\n    unittest.main()#src/config.py\nimport os\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    MAIL_SERVER = 'smtp.googlemail.com'\n    MAIL_PORT = 587\n    MAIL_USE_TLS = True\n    MAIL_USERNAME = os.environ.get('EMAIL_USER')\n    MAIL_PASSWORD = os.environ.get('EMAIL_PASS')\n    S3_BUCKET = os.environ.get(\"S3_BUCKET_NAME\")\n    S3_KEY = os.environ.get(\"S3_ACCESS_KEY\")\n    S3_SECRET = os.environ.get(\"S3_SECRE"}
{"task_id": "HumanEval/2", "completion": "    return number % 1\n\n\ndef main():\n    \"\"\"\n    Main function to test the other functions.\n    \"\"\"\n    print(f\"The number 3.5 has a decimal part of {truncate_number(3.5)}\")\n    print(f\"The number 4.7 has a decimal part of {truncate_number(4.7)}\")\n    print(f\"The number 10.99 has a decimal part of {truncate(10.99)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n#tests/test_truncate_number.py\nimport pytest\nfrom truncate_number import truncate_number\n\n\ndef test_truncate_number():\n    assert truncate_number(3.5) == 0.5\n    assert truncate_number(4.7) == 0.7\n    assert truncate_number(10.99) == 0.99\n    assert truncate_number(0) == 0\n    assert truncate_number(-3.5) == 0.5\n    assert truncate_number(-4.7) == 0.7\n    assert truncate_number(-10.99) == 0.99\n    assert truncate_number(float('inf')) == 0\n    assert truncate_number(float('-inf')) == 0\n    assert truncate_number(float('nan')) == float('nan')\n\n#tests/test_truncate_number_2.py\nimport pytest\nfrom truncate_number import truncate_number\n\n\ndef test_truncate_number():\n    assert truncate_number(3.5) == 0.5\n    assert truncate_number(4.7) == 0.7\n    assert truncate_number(10.99) == 0.99\n    assert truncate_number(0) == 0\n    assert truncate_number(-3.5) == 0.5\n    assert truncate_number(-4.7) == 0.7\n    assert truncate_number(-10.99) == 0.99\n    assert truncate_number(float('inf')) == 0\n    assert truncate"}
{"task_id": "HumanEval/107", "completion": "    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n\n    even_count = sum(is_palindrome(i) for i in range(1, n+1) if i % 2 == 0)\n    odd_count = sum(is_palindrome(i) for i in range(1, n+1) if i % 2 != 0)\n\n    return (even_count, odd_count)\n\n\nprint(even_odd_palindrome(3))  # (1, 2)\nprint(even_odd_palindrome(12))  # (4, 6)\nprint(even.even_odd_palindrome(1000))  # (400, 600)\n\n# 1000개의 숫자 중에서 회문이 몇 개인지 찾아보자.\n# 1000까지의 숫자 중에서 회문이 몇 개인지 찾아보자.\n# 1000까지의 숫자 중에서 회문이 몇 개인지 찾아보자.\n# 1000까지의 숫자 중에서 회문이 몇 개인지 찾아보자.\n# 1000까지의 숫자 중에서 회문이 몇 개인지 "}
{"task_id": "HumanEval/66", "completion": "    return sum(ord(c) for c in s if c.isupper())\n\n\nprint(digitSum(\"abAB\"))  # 131\nprint(digitSum(\"abcCd\"))  # 67\nprint(digitSum(\"helloE\"))  # 69\nprint(digitSum(\"woArBld\"))  # 131\nprint(digitSum(\"aAaaaXa\"))  # 153\nprint(digitSum(\"\"))  # 0\n\n# 131 is the sum of ASCII values of A (65) and B (66)\n# 67 is the sum of ASCII values of a (97), b (98) and C (67)\n# 69 is the sum of ASCII values of h (104), e (101) and E (69)\n# 131 is the sum of ASCII values of w (119), o (111), A (65) and B (66)\n# 153 is the sum of ASCII values of a (97), A (65), a (97), a (97) and X (88)\n# 0 is the sum of no uppercase characters.\n\n# ord() function returns an integer representing the Unicode character.\n# isupper() method returns True if the string is an uppercase letter.\n# sum() function returns the sum of all items in an iterable.\n# The iterable items are the ASCII values of the uppercase characters in the string.\n# If there are no uppercase characters, the sum is 0.\n\n# ord('A') = 65, ord('B') = 66, ord('C') = 67, and so on.\n# ord('a') = 97, ord('b') = 98, ord('c') = 99, and so on.\n# ord('h') = 104, ord('e') = 101, ord('E') = 69, and so on.\n# ord('w') = 119, ord('o') = 111, ord('A') = 65, ord('B') = 66, and so on.\n#"}
{"task_id": "HumanEval/75", "completion": "    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    factors = []\n    for i in range(2, a):\n        if a % i == 0 and is_prime(i):\n            factors.append(i)\n            a //= i\n            if len(factors) > 3:\n                return False\n    return len(factors) == 3 and is_prime(a)\n\n\nprint(is_multiply_prime(30))  # True\nprint(is_multiply_prime(105))  # True\nprint(is_multiply_prime(100))  # False\nprint(is_multiply_prime(120))  # False\nprint(is_multiply_prime(135))  # False\nprint(is_multiply_prime(150))  # False\nprint(is_multiply_prime(165))  # False\nprint(is_multiply_prime(180))  # False\nprint(is_multiply_prime(195))  # False\nprint(is_multiply_prime(210))  # False\nprint(is_multiply_prime(225))  # False\nprint(is_multiply_prime(240))  # False\nprint(is_multiply_prime(255))  # False\nprint(is_multiply_prime(270))  # False\nprint(is_multiply_prime(285))  # False\nprint(is_multiply_prime(300))  # False\nprint(is_multiply_prime(315))  # False\nprint(is_multiply_prime(330))  # False\nprint(is_multiply_prime(345))  # False\nprint(is_multiply_prime(360))  # False\nprint(is_multiply_prime(375))"}
{"task_id": "HumanEval/4", "completion": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(n - mean) for n in numbers) / len(numbers)\n\n\ndef mean_absolute_percentage_error(y_true: List[float], y_pred: List[float]) -> float:\n    \"\"\" For a given list of true values and predicted values, calculate Mean Absolute Percentage Error.\n    Mean Absolute Percentage Error is the average of the absolute percentage difference between the\n    predicted and actual values:\n    MAPE = [sum(|(y_true_i - y_pred_i) / y_true_i|) for y_true_i, y_pred_i in zip(y_true, y_pred)]\n    >>> mean_absolute_percentage_error([1.0, 2.0, 3.0, 4.0], [1.1, 1.9, 3.2, 3.8])\n    0.14285714285714285\n    \"\"\"\n    return sum(abs((y_true_i - y_pred_i) / y_true_i) for y_true_i, y_pred_i in zip(y_true, y_pred)) / len(y_true)\n\n\ndef mean_squared_error(y_true: List[float], y_pred: List[float]) - float:\n    \"\"\" For a given list of true values and predicted values, calculate Mean Squared Error.\n    Mean Squared Error is the average of the squares of the errors:\n    MSE = [sum((y_true_i - y_pred_i)^2) for y_true_i, y_pred_i in zip(y_true, y_pred)]\n    >>> mean_squared_error([1.0, 2.0, 3.0, 4.0], [1.1, 1.9, 3.2, 3.8])\n    0.04761904761904762\n    \"\"\"\n    return sum((y_true_i - y_pred_"}
{"task_id": "HumanEval/102", "completion": "    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1\n\n\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12))  # -1\nprint(choose_num(12, 15))  # 14\nprint(choose_num(13, 12"}
{"task_id": "HumanEval/18", "completion": "    count = start = 0\n    while True:\n        start = string.find(substring, start) + 1\n        if start > 0:\n            count += 1\n        else:\n            return count\n\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n    s = input()\n    sub_s = input()\n    print(how_many_times(s, sub_s))import re\n\n\ndef find_all_substrings(input_string):\n    length = len(input_string)\n    return [input_string[i: j] for i in range(length) for j in range(i + 1, length + 1)]\n\n\ndef count_subsequences(string):\n    return len(find_all_substrings(string))\n\n\ndef count_subsequences_v2(string):\n    return sum([len(re.findall(f'(?={string[i]})', string)) for i in range(len(string))])\n\n\ndef count_subsequences_v3(string):\n    return sum([string[i:].count(string[i]) for i in range(len(string))])\n\n\nif __name__ == '__main__':\n    s = input()\n    print(count_subsequences(s))\n    print(count_subsequences_v2(s))\n    print(count_subsequences_v3(s))\n\n# print(find_all_substrings('abc'))\n# print(count_subsequences('abc'))\n# print(count_subsequences_v2('abc'))\n# print(count_subsequences_v3('abc'))\n# print(count_subsequences('aaa'))\n# print(count_subsequences_v2('aaa'))\n# print(count_subsequences_v3('aaa'))\n# print(count_subsequences('abab'))\n# print(count_subsequences_v2('abab'))\n# print(count_subsequences_v3('abab'))\n# print(count_subsequences('abcabc'))\n# print(count_subsequences"}
{"task_id": "HumanEval/161", "completion": "    if not any(char.isalpha() for char in s):\n        return s[::-1]\n    else:\n        return ''.join([char.upper() if char.islower() else char.lower() for char in s])\n\n\nprint(solve(\"1234\"))  # \"4321\"\nprint(solve(\"ab\"))  # \"AB\"\nprint(solve(\"#a@C\"))  # \"#A@c\"\nprint(solve(\"aBc\"))  # \"AbC\"\nprint(solve(\"1234ABC\"))  # \"4321abc\"\nprint(solve(\"aBc1234\"))  # \"AbC4321\"\nprint(solve(\"1234ab\"))  # \"4321AB\"\nprint(solve(\"1234AbC\"))  # \"4321aBc\"\nprint(solve(\"1234ABC\"))  # \"4321abc\"\nprint(solve(\"1234ab\"))  # \"4321AB\"\nprint(solve(\"1234AbC\"))  \"4321aBc\"\nprint(solve(\"1234ABC\"))  \"4321abc\"\nprint(solve(\"1234ab\"))  \"4321AB\"\nprint(solve(\"1234AbC\"))  \"4321aBc\"\nprint(solve(\"1234ABC\"))  \"4321abc\"\nprint(solve(\"1234ab\"))  \"4321AB\"\nprint(solve(\"1234AbC\"))  \"4321aBc\"\nprint(solve(\"1234ABC\"))  \"4321abc\"\nprint(solve(\"1234ab\"))  \"4321AB\"\nprint(solve(\"1234AbC\"))  \"4321aBc\"\nprint(solve(\"1234ABC\"))  \"4321abc\"\nprint(solve(\"123"}
{"task_id": "HumanEval/139", "completion": "    if n == 0:\n        return 1\n    else:\n        return n * special_factorial(n - )\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_special_factorial.py\nimport unittest\nfrom special_factorial import special_factorial\n\nclass TestSpecialFactorial(unittest.TestCase):\n\n    def test_special_factorial(self):\n        self.assertEqual(special_factorial(0), 1)\n        self.assertEqual(special_factorial(1), 1)\n        self.assertEqual(special_factorial(2), 2)\n        self.assertEqual(special_factorial(3), 12)\n        self.assertEqual(special_factorial(4), 288)\n        self.assertEqual(special_factorial(5), 34560)\n\nif __name__ == '__main__':\n    unittest.main()def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n * (n-1) * (n-2) * ... * 1\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    24\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n * special_factorial(n - 1)\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_special_factorial.py\nimport unittest\nfrom special_factorial import special_factorial\n\nclass TestSpecialFactorial(unittest.TestCase):\n\n    def test_special_factorial(self):\n        self.assertEqual(special_factorial(0), 1)\n        self.assertEqual(special_factorial(1), 1)\n        self.assertEqual(special_factorial(2), 2)\n        self.assertEqual(special"}
{"task_id": "HumanEval/44", "completion": "    if x < base:\n        return str(x)\n    else:\n        return change_base(x // base, base) + str(x % base)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_02.py\ndef is_palindrome(s: str) -> bool:\n    \"\"\"Check if string s is palindrome.\n    >>> is_palindrome('radar')\n    True\n    >>> is_palindrome('python')\n    False\n    \"\"\"\n    if len(s) < 2:\n        return True\n    if s[0] != s[-1]:\n        return False\n    return is_palindrome(s[1:-1])\n\n\ndef main():\n    import doctest\n    doctest\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_03.py\ndef sum_of_digits(n: int) -> int:\n    \"\"\"Calculate the sum of digits of the number n.\n    >>> sum_of_digits(1234)\n    10\n    >>> sum_of_digits(5678)\n    29\n    \"\"\"\n    if n == 0:\n        return 0\n    return n % 10 + sum_of_digits(n // 10)\n\n\ndef main():\n    import doctest\n    doctest.testmod()\n\n\nif __name__ == \"__main__\":\n    main()\n\n#lab_03/task_04.py\ndef gcd(a: int, b: int) -> int:\n    \"\"\"Calculate the greatest common divisor of a and b.\n    >>> gcd(12, 8)\n    4\n    >>> gcd(16, 24)\n    8\n    \"\"\"\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef main():\n    import doctest\n    doctest.testmod"}
{"task_id": "HumanEval/51", "completion": "    return ''.join([c for c in text if c.lower() not in 'aeiou'])\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_remove_vowels.py\nimport unittest\nfrom remove_vowels import remove_vowels\n\n\nclass TestRemoveVowels(unittest.TestCase):\n\n    def test_remove_vowels(self):\n        self.assertEqual(remove_vowels(''), '')\n        self.assertEqual(remove_vowels(\"abcdef\\nghijklm\"), 'bcdf\\nghjklm')\n        self.assertEqual(remove_vowels('abcdef'), 'bcdf')\n        self.assertEqual(remove_vowels('aaaaa'), '')\n        self.assertEqual(remove_vowels('aaBAA'), 'B')\n        self.assertEqual(remove_vowels('zbcd'), 'zbcd')\n\n\nif __name__ == \"__main__\":\n    unittest.main()#src/config.py\nimport os\n\nclass Config:\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    MAIL_SERVER = 'smtp.googlemail.com'\n    MAIL_PORT = 587\n    MAIL_USE_TLS = True\n    MAIL_USERNAME = os.environ.get('EMAIL_USER')\n    MAIL_PASSWORD = os.environ.get('EMAIL_PASS')\n    S3_BUCKET = os.environ.get(\"S3_BUCKET_NAME\")\n    S3_KEY = os.environ.get(\"S3_ACCESS_KEY\")\n    S3_SECRET = os.environ.get(\"S3_SECRET_ACCESS_KEY\")\n    S3_LOCATION = f\"http://{S3_BUCK"}
{"task_id": "HumanEval/93", "completion": "    vowels = 'aeiou'\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    ALPHABET = alphabet.upper()\n    encoded_message = ''\n\n    for char in message:\n        if char in alphabet:\n            encoded_message += ALPHABET[alphabet.index(char)]\n        elif char in ALPHABET:\n            encoded_message += alphabet[ALPHABET.index(char)]\n        elif char in vowels:\n            encoded_message += alphabet[(alphabet.index(char) + 2) % 26]\n        elif char in vowels.upper():\n            encoded_message += ALPHABET[(ALPHABET.index(char) + 2) % 26]\n        else:\n            encoded_message += char\n\n    return encoded_message\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n\n#tests/test_encode.py\nimport unittest\nfrom encode import encode\n\n\nclass TestEncode(unittest.TestCase):\n\n    def test_encode(self):\n        self.assertEqual(encode('test'), 'tGST')\n        self.assertEqual(encode('This is a message'), 'tHKS KS C MGSSCGG')\n        self.assertEqual(encode('AEIOU'), 'CGMKW')\n        self.assertEqual(encode('aeiou'), 'cgmkw')\n        self.assertEqual(encode('12345'), '12345')\n        self.assertEqual(encode(' '), ' ')\n        self.assertEqual(encode('This is a message with numbers 12345 and special characters $%^&*'), 'tHKS KS C MGSSCGG wKH NMZ VDZQ 12345 KD ZGGLSG $%^&*')\n\n\nif __name__ == '__main__':\n    unittest.main()def is_palindrome(s):\n    \"\"\"\n    Write a function that checks if a string is a palindrome.\n    A palindrome is a word"}
{"task_id": "HumanEval/91", "completion": "    return sum(1 for c in S if c in '.?!')\n\n\ndef is_bored_v2(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!' and can be in uppercase or lowercase.\n   \n    For example:\n    >>> is_bored_v2(\"Hello world\")\n    0\n    >>> is_bored_v2(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    return sum(1 for c in S if c in '.?!')\n\n\ndef is_bored_v3(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!' and can be in uppercase or lowercase.\n   \n    For example:\n    >>> is_bored_v3(\"Hello world\")\n    0\n    >>> is_bored_v3(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    return sum(1 for c in S if c in '.?!')\n\n\ndef is_bored_v4(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!' and can be in uppercase or lowercase.\n   \n    For example:\n    >>> is_bored_v4(\"Hello world\")\n    0\n    >>> is_bored_v4(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    return sum(1 for c in S if c in '.?!')\n\n\ndef is_bored_v5(S):\n    \"\"\"\n    You'll be given a string of words, and your"}
{"task_id": "HumanEval/14", "completion": "    return [string[:i] for i in range(1, len(string) + 1)]\n\ndef all_suffixes(string: str) -> List[str]:\n    \"\"\" Return list of all suffixes from shortest to longest of the input string\n    >>> all_suffixes('abc')\n    ['c', 'bc', 'abc']\n   \n    \"\"\"\n    return [string[i:] for i in range(len(string))]\n\ndef all_substrings(string: str) -> List[str]:\n    \"\"\" Return list of all substrings from shortest to longest of the input string\n    >>> all_substrings('abc')\n    ['a', 'ab', 'abc', 'b', 'bc', 'c']\n    \"\"\"\n    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1)]\n\ndef all_substrings_of_length(string: str, length: int) -> List[str]:\n    \"\"\" Return list of all substrings of the input string of the specified length\n    >>> all_substrings_of_length('abc', 2)\n    ['ab', 'bc']\n    \"\"\"\n    return [string[i:i + length] for i in range(len(string) - length + 1)]\n\ndef all_palindromes(string: str) -> List[str]:\n    \"\"\" Return list of all palindromes in the input string\n    >>> all_palindromes('abcba')\n    ['a', 'b', 'c', 'b', 'abcba']\n    \"\"\"\n    return [string[i:j] for i in range(len(string)) for j in range(i + 1, len(string) + 1) if string[i:j] == string[i:j][::-1]]\n\ndef all_palindromes_of_length(string: str, length: int) -> List[str]:\n    \"\"\" Return list of all palindromes in the input string of the specified length\n    >>> all_palindromes_of_length('abcba', 3)\n    ['abc', 'bcb']\n    \"\"\"\n    return [string["}
{"task_id": "HumanEval/56", "completion": "    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\":\n            if not stack or stack[-1] != \"<\":\n                return False\n            stack.pop()\n    return not stack\n\n\ndef test_correct_bracketing():\n    assert correct_bracketing(\"<\") == False\n    assert correct_bracketing(\"<>\") == True\n    assert correct_bracketing(\"<<><>>\") == True\n    assert correct_bracketing(\"><<>\") == False\n\n\ntest_correct_bracketing()\n\n# 2.2\n\n\ndef longest_substring(s: str):\n    \"\"\"\n    return the length of the longest substring without repeating characters.\n\n    >>> longest_substring(\"abcabcbb\")\n    3\n    >>> longest_substring(\"bbbbbb\")\n    1\n    >>> longest_substring(\"pwwkew\")\n    3\n    \"\"\"\n    char_set = set()\n    left = 0\n    result = 0\n\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(s[right])\n        result = max(result, right - left + 1)\n    return result\n\n\ndef test_longest_substring():\n    assert longest_substring(\"abcabcbb\") == 3\n    assert longest_substring(\"bbbbbb\") == 1\n    assert longest_substring(\"pwwkew\") == 3\n\n\ntest_longest_substring()\n\n# 2.3\n\n\ndef longest_substring_k_distinct(s: str, k: int):\n    \"\"\"\n    return the length of the longest substring with at most k distinct characters.\n\n    >>> longest_substring_k_distinct(\"abcabcbb\", 2)\n    3\n    >>> longest_substring_k_distinct(\"bbbbbb\", 1)\n    1\n    >>> longest_substring_k_distinct(\"pwwkew\", 1)\n    1"}
